import numpy as np
from typing import Union, List

from cosmic.event import Event
from cosmic.saeta import Saeta
from cosmic.hit import Hit
from utils.const import NTRACK, NPLAN, LENX, LENY, LENZ, VZ1, TINI, SINI, THMAX


class SimEvent:
    def __init__(self, tracks_number: Union[int, None] = NTRACK):
        """ C L A S S - C O N S T R U C T O R

        Args:
            tracks_number (int, optional): Number of tracks to generate

        Attributes:
            self.tracks_number (int): Number of tracks generated across the detector.
        """

        if tracks_number is None:
            self.tracks_number = self.rd_tracks_number()
        else:
            self.tracks_number = tracks_number

        self.event = Event()

        self.gene_tracks()
        self.digitization()

    @staticmethod
    def rd_tracks_number() -> int:
        """
        Generate a realistic randomized number of tracks passing
        through the detector.

        :return: Number of tracks to generate.
        """
        # Number of tracks:
        tracks = [1, 2, 3, 4]

        # Probabilities for each number of tracks:
        probs = [0.9, 0.09, 0.009, 0.001]

        return np.random.choice(tracks, p=probs)

    @staticmethod
    def set_T0(t_random: bool = True):
        """
        Defines initial value for initial time of each saeta:

        :param t_random: Choose if set T0 randomly or equal to TINI
        """
        if t_random:
            return (1 + np.random.random() / 2) * TINI
        else:
            return TINI

    @staticmethod
    def angle_distribution(th_max: float, azimuthal: str = "uniform", zenithal: str = "uniform"):
        """
        Generates random 3D polar angles (theta and phi)

        :param th_max: Maximum theta angle (in degrees)
        :param azimuthal: Azimuthal distribution: ['uniform' (default), 'costh2']
        :param zenithal: Zenithal distribution: ['uniform' (default)]
        :return:
            - Theta: Random theta angle generated by uniform distribution in
            cosine, between 0 and th_max.
            - Phi: Random phi angle generated by uniform distribution in angle,
            between 0 and 2 * pi.
        """
        # Theta:
        if azimuthal == "uniform":
            cos_theta_max = np.cos(np.deg2rad(th_max))  # Theta max angle cosine
            # Uniform distribution in cos(theta) and phi
            rcth = 1 - np.random.random() * (1 - cos_theta_max)
            tth = np.arccos(rcth)  # theta random angle
        elif azimuthal == "costh2":
            rcth = np.random.random() ** (1 / 4)
            tth = np.arccos(rcth)
        else:
            tth = 0
            raise Exception("Parameter 'azimuthal' must be: 'uniform' (default) or 'costh2'")

        # Phi:
        if zenithal == "uniform":
            tph = np.random.random() * 2 * np.pi  # phi random angle
        else:
            tph = 0
            raise Exception("Parameter 'zenithal' must be: 'uniform' (default)")

        return tth, tph

    def gene_tracks(self):
        """
        It generates random parameters to create tracks as Saetas.

        Uniform distribution in cos(theta) and phi

        If the track doesn't enter in the detector, it is deleted from the list.

        :return generated_tracks: Matrix of generated tracks (initial saetas_array).
        :return tracks_number: Total number of tracks in the detector
        """

        count_tracks = 0
        while count_tracks < self.tracks_number:
            theta, phi = self.angle_distribution(THMAX)

            X0 = np.random.random() * LENX
            Y0 = np.random.random() * LENY
            T0 = self.set_T0()
            S0 = SINI

            # Director Cosines
            cx = np.sin(theta) * np.cos(phi)
            cy = np.sin(theta) * np.sin(phi)
            cz = np.cos(theta)
            XP = cx / cz  # projected slope in the X-Z plane
            YP = cy / cz  # projected slope in the Y-Z plane

            # Coordinate where would the particle come out
            xz_end = X0 + XP * LENZ
            yz_end = Y0 + YP * LENZ

            # We refer the coordinate to the detector center (x_mid, y_mid)
            x_mid = xz_end - (LENX / 2)
            y_mid = yz_end - (LENY / 2)

            # We check if the particle has entered the detector
            if np.abs(x_mid) < (LENX / 2) and np.abs(y_mid) < (LENY / 2):
                self.event.add_saeta(Saeta(X0, XP, Y0, YP, T0, S0))
                count_tracks += 1

    def digitization(self):
        """
        # ======== DIGITIZATION FOR TRAGALDABAS DETECTOR ======== #

        It converts the parameters inside mtgen to discrete
        numerical values, which are the cell indices (hit_digits) and
        cell central positions (hit_coords).

        - hit_digits --> (kx1, ky2, time1, kx2, ky2, time2, ...)  Indices of impact
        - hit_coords --> ( X1,  Y1,    T1,  X2,  Y2,    T2, ...)  Real points of impact / mm
        :return: hit_digits (cell indices k_mat) and hit_coords (cell central
            positions k_mat).
        """

        for it in range(self.event.multiplicity):
            saeta = self.event.saeta(it)

            for ip in range(NPLAN):
                zi = VZ1[ip]  # current Z

                # Set saeta at height zi
                saeta.z0 = zi
                xi, _, yi, _, ti, _ = saeta.coords

                # Position indices of the impacted cells (cell index)
                col, row, time = saeta.digitized

                hit = Hit(ip, col, row, time)
                self.event.add_hit(hit, randomize=True)

    @property
    def hits_num(self) -> int:
        """
        Number of total hits in event

        :return: Number of hits.
        """
        return len(self.event.hits)

    @property
    def hit_coords(self) -> np.array:
        """
        Hit coordinates

        :return: Numpy array with all hits coordinates
        """
        hits = np.zeros((0, 4))
        for hit in range(self.hits_num):
            hits = np.vstack((hits, self.event.hits[hit].values))
        return hits

    @property
    def hits(self) -> List[object]:
        """
        Hit objects

        :return: List with all hit objects
        """
        return self.event.hits


if __name__ == "__main__":
    sim = SimEvent()
    sim.event.print_saetas()
